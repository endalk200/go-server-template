// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: commands_tags.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const attachCommandToTag = `-- name: AttachCommandToTag :one
INSERT INTO command_tags (command_id, tag_id)
VALUES ($1, $2)
RETURNING command_id, tag_id
`

type AttachCommandToTagParams struct {
	CommandID uuid.UUID `json:"command_id"`
	TagID     uuid.UUID `json:"tag_id"`
}

func (q *Queries) AttachCommandToTag(ctx context.Context, arg AttachCommandToTagParams) (CommandTag, error) {
	row := q.db.QueryRow(ctx, attachCommandToTag, arg.CommandID, arg.TagID)
	var i CommandTag
	err := row.Scan(&i.CommandID, &i.TagID)
	return i, err
}

const deleteCommand = `-- name: DeleteCommand :exec
DELETE FROM commands
WHERE id = $1
`

func (q *Queries) DeleteCommand(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommand, id)
	return err
}

const deleteCommandTagRelationByCommandId = `-- name: DeleteCommandTagRelationByCommandId :exec
DELETE FROM command_tags
WHERE command_id = $1
`

func (q *Queries) DeleteCommandTagRelationByCommandId(ctx context.Context, commandID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommandTagRelationByCommandId, commandID)
	return err
}

const deleteCommandTagRelationByTagId = `-- name: DeleteCommandTagRelationByTagId :exec
DELETE FROM command_tags
WHERE tag_id = $1
`

func (q *Queries) DeleteCommandTagRelationByTagId(ctx context.Context, tagID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCommandTagRelationByTagId, tagID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags
WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTag, id)
	return err
}

const findCommands = `-- name: FindCommands :many
SELECT id, user_id, command, description, created_at, updated_at FROM commands
WHERE (user_id = $1)
`

func (q *Queries) FindCommands(ctx context.Context, userID uuid.UUID) ([]Command, error) {
	rows, err := q.db.Query(ctx, findCommands, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Command
	for rows.Next() {
		var i Command
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Command,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommandsByTagId = `-- name: FindCommandsByTagId :many
SELECT 
    c.id AS command_id, c.command AS command_name, c.description AS command_description, c.created_at AS command_created_at, c.updated_at AS command_updated_at,
    t.id AS tag_id, t.name AS tag_name, t.description AS tag_description, t.created_at AS tag_created_at, t.updated_at AS tag_updated_at
FROM commands c
LEFT JOIN command_tags ct ON c.id = ct.command_id
LEFT JOIN tags t ON ct.tag_id = t.id
WHERE t.id = $1
`

type FindCommandsByTagIdRow struct {
	CommandID          uuid.UUID          `json:"command_id"`
	CommandName        string             `json:"command_name"`
	CommandDescription string             `json:"command_description"`
	CommandCreatedAt   pgtype.Timestamptz `json:"command_created_at"`
	CommandUpdatedAt   pgtype.Timestamptz `json:"command_updated_at"`
	TagID              pgtype.UUID        `json:"tag_id"`
	TagName            pgtype.Text        `json:"tag_name"`
	TagDescription     pgtype.Text        `json:"tag_description"`
	TagCreatedAt       pgtype.Timestamptz `json:"tag_created_at"`
	TagUpdatedAt       pgtype.Timestamptz `json:"tag_updated_at"`
}

func (q *Queries) FindCommandsByTagId(ctx context.Context, id uuid.UUID) ([]FindCommandsByTagIdRow, error) {
	rows, err := q.db.Query(ctx, findCommandsByTagId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommandsByTagIdRow
	for rows.Next() {
		var i FindCommandsByTagIdRow
		if err := rows.Scan(
			&i.CommandID,
			&i.CommandName,
			&i.CommandDescription,
			&i.CommandCreatedAt,
			&i.CommandUpdatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagDescription,
			&i.TagCreatedAt,
			&i.TagUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCommandsWithTags = `-- name: FindCommandsWithTags :many
SELECT 
    c.id AS command_id, c.command AS command_name, c.description AS command_description, c.created_at AS command_created_at, c.updated_at AS command_updated_at,
    t.id AS tag_id, t.name AS tag_name, t.description AS tag_description, t.created_at AS tag_created_at, t.updated_at AS tag_updated_at
FROM commands c
LEFT JOIN command_tags ct ON c.id = ct.command_id
LEFT JOIN tags t ON ct.tag_id = t.id
WHERE c.user_id = $1
`

type FindCommandsWithTagsRow struct {
	CommandID          uuid.UUID          `json:"command_id"`
	CommandName        string             `json:"command_name"`
	CommandDescription string             `json:"command_description"`
	CommandCreatedAt   pgtype.Timestamptz `json:"command_created_at"`
	CommandUpdatedAt   pgtype.Timestamptz `json:"command_updated_at"`
	TagID              pgtype.UUID        `json:"tag_id"`
	TagName            pgtype.Text        `json:"tag_name"`
	TagDescription     pgtype.Text        `json:"tag_description"`
	TagCreatedAt       pgtype.Timestamptz `json:"tag_created_at"`
	TagUpdatedAt       pgtype.Timestamptz `json:"tag_updated_at"`
}

func (q *Queries) FindCommandsWithTags(ctx context.Context, userID uuid.UUID) ([]FindCommandsWithTagsRow, error) {
	rows, err := q.db.Query(ctx, findCommandsWithTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindCommandsWithTagsRow
	for rows.Next() {
		var i FindCommandsWithTagsRow
		if err := rows.Scan(
			&i.CommandID,
			&i.CommandName,
			&i.CommandDescription,
			&i.CommandCreatedAt,
			&i.CommandUpdatedAt,
			&i.TagID,
			&i.TagName,
			&i.TagDescription,
			&i.TagCreatedAt,
			&i.TagUpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTagById = `-- name: FindTagById :one
SELECT id, user_id, name, description, created_at, updated_at FROM tags
WHERE (id = $1)
`

func (q *Queries) FindTagById(ctx context.Context, id uuid.UUID) (Tag, error) {
	row := q.db.QueryRow(ctx, findTagById, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTagByName = `-- name: FindTagByName :one
SELECT id, user_id, name, description, created_at, updated_at FROM tags
WHERE (name = $1)
`

func (q *Queries) FindTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, findTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findTags = `-- name: FindTags :many
SELECT id, user_id, name, description, created_at, updated_at FROM tags
WHERE (user_id = $1)
`

func (q *Queries) FindTags(ctx context.Context, userID uuid.UUID) ([]Tag, error) {
	rows, err := q.db.Query(ctx, findTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTagsWithCommands = `-- name: FindTagsWithCommands :many
SELECT 
    t.id AS tag_id, t.name AS tag_name, t.description AS tag_description,
    c.id AS command_id, c.command AS command_name, c.description AS command_description
FROM tags t
LEFT JOIN command_tags ct ON t.id = ct.tag_id
LEFT JOIN commands c ON ct.command_id = c.id
WHERE t.user_id = $1
`

type FindTagsWithCommandsRow struct {
	TagID              uuid.UUID   `json:"tag_id"`
	TagName            string      `json:"tag_name"`
	TagDescription     pgtype.Text `json:"tag_description"`
	CommandID          pgtype.UUID `json:"command_id"`
	CommandName        pgtype.Text `json:"command_name"`
	CommandDescription pgtype.Text `json:"command_description"`
}

func (q *Queries) FindTagsWithCommands(ctx context.Context, userID uuid.UUID) ([]FindTagsWithCommandsRow, error) {
	rows, err := q.db.Query(ctx, findTagsWithCommands, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindTagsWithCommandsRow
	for rows.Next() {
		var i FindTagsWithCommandsRow
		if err := rows.Scan(
			&i.TagID,
			&i.TagName,
			&i.TagDescription,
			&i.CommandID,
			&i.CommandName,
			&i.CommandDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCommands = `-- name: InsertCommands :one
INSERT INTO commands (
  id, user_id, command, description
) VALUES (
  uuid_generate_v4(), $1, $2, $3::Text
)
RETURNING id, user_id, command, description, created_at, updated_at
`

type InsertCommandsParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	Command     string      `json:"command"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) InsertCommands(ctx context.Context, arg InsertCommandsParams) (Command, error) {
	row := q.db.QueryRow(ctx, insertCommands, arg.UserID, arg.Command, arg.Description)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Command,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertTag = `-- name: InsertTag :one

INSERT INTO tags (
  id, user_id, name, description
) VALUES (
  uuid_generate_v4(), $1, $2, $3::Text
)
RETURNING id, user_id, name, description, created_at, updated_at
`

type InsertTagParams struct {
	UserID      uuid.UUID   `json:"user_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

// SELECT
//
//	c.id AS command_id,
//	c.command AS command_name,
//	c.description AS command_description,
//	c.created_at AS command_created_at,
//	c.updated_at AS command_updated_at,
//	array_agg(
//	    json_build_object(
//	        'id', t.id,
//	        'name', t.name,
//	        'description', t.description
//	    )
//	) AS tags
//
// FROM commands c
// LEFT JOIN command_tags ct ON c.id = ct.command_id
// LEFT JOIN tags t ON ct.tag_id = t.id
// WHERE c.user_id = $1
// GROUP BY c.id;
func (q *Queries) InsertTag(ctx context.Context, arg InsertTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, insertTag, arg.UserID, arg.Name, arg.Description)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const replaceCommandTag = `-- name: ReplaceCommandTag :exec
WITH deleted AS (
    DELETE FROM command_tags
    WHERE command_id = $1
)
INSERT INTO command_tags (command_id, tag_id)
VALUES ($1, $2)
`

type ReplaceCommandTagParams struct {
	CommandID uuid.UUID `json:"command_id"`
	TagID     uuid.UUID `json:"tag_id"`
}

func (q *Queries) ReplaceCommandTag(ctx context.Context, arg ReplaceCommandTagParams) error {
	_, err := q.db.Exec(ctx, replaceCommandTag, arg.CommandID, arg.TagID)
	return err
}

const updateCommand = `-- name: UpdateCommand :one
UPDATE commands
SET command = COALESCE(NULLIF($2, ''), command),
    description = COALESCE(NULLIF($3, ''), description)
WHERE id = $1
RETURNING id, user_id, command, description, created_at, updated_at
`

type UpdateCommandParams struct {
	ID      uuid.UUID   `json:"id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

func (q *Queries) UpdateCommand(ctx context.Context, arg UpdateCommandParams) (Command, error) {
	row := q.db.QueryRow(ctx, updateCommand, arg.ID, arg.Column2, arg.Column3)
	var i Command
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Command,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET name = COALESCE(NULLIF($2, ''), name),
    description = COALESCE(NULLIF($3, ''), description)
WHERE id = $1
RETURNING id, user_id, name, description, created_at, updated_at
`

type UpdateTagParams struct {
	ID      uuid.UUID   `json:"id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, updateTag, arg.ID, arg.Column2, arg.Column3)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
